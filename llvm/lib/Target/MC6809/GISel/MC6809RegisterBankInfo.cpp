//===- MC6809RegisterBankInfo.cpp -----------------------------------*- C++ -*-==//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
/// \file
/// This file implements the targeting of the RegisterBankInfo class for MC6809.
/// \todo This should be generated by TableGen.
//===----------------------------------------------------------------------===//

#include "GISel/MC6809RegisterBankInfo.h"
#include "MC6809InstrInfo.h" // For the register classes
#include "MC6809Subtarget.h"
#include "llvm/CodeGen/MachineRegisterInfo.h"
#include "llvm/CodeGen/RegisterBank.h"
#include "llvm/CodeGen/RegisterBankInfo.h"
#include "llvm/CodeGen/TargetRegisterInfo.h"

#define GET_TARGET_REGBANK_IMPL
#include "MC6809GenRegisterBank.inc"

using namespace llvm;

// FIXME: TableGen this.
// If it grows too much and TableGen still isn't ready to do the job, extract it
// into an MC6809GenRegisterBankInfo.def (similar to AArch64).
namespace llvm {
namespace MC6809 {
enum PartialMappingIdx {
  PMI_BIT1,
  PMI_ACC8,
  PMI_ACC16,
  PMI_ACC32,
  PMI_INDEX
};

RegisterBankInfo::PartialMapping PartMappings[]{
    // BIT1 Partial Mapping
    {0, 1, ACCUMRegBank},
    // ACC8 Partial Mapping
    {0, 8, ACCUMRegBank},
    // ACC16 Partial Mapping
    {0, 16, ACCUMRegBank},
    // ACC32 Partial Mapping
    {0, 32, ACCUMRegBank},
    // INDEX Partial Mapping
    {0, 16, INDEXRegBank},
};

enum ValueMappingIdx {
  InvalidIdx = 0,
  BIT1_3OpsIdx = 1,
  ACC8_3OpsIdx = 4,
  ACC16_3OpsIdx = 7,
  ACC32_3OpsIdx = 10,
  INDEX_ACC8_3OpsIdx = 13,
  INDEX_ACC16_3OpsIdx = 16,
  FLAGOpsIdx = 19,
};

RegisterBankInfo::ValueMapping ValueMappings[] = {
    // invalid
    {nullptr, 0},
    // 3 ops in BIT1
    {&PartMappings[PMI_BIT1], 1},
    {&PartMappings[PMI_BIT1], 1},
    {&PartMappings[PMI_BIT1], 1},
    // 3 ops in ACC8
    {&PartMappings[PMI_ACC8], 1},
    {&PartMappings[PMI_ACC8], 1},
    {&PartMappings[PMI_ACC8], 1},
    // 3 ops in ACC16
    {&PartMappings[PMI_ACC16], 1},
    {&PartMappings[PMI_ACC16], 1},
    {&PartMappings[PMI_ACC16], 1},
    // 3 ops in ACC32
    {&PartMappings[PMI_ACC32], 1},
    {&PartMappings[PMI_ACC32], 1},
    {&PartMappings[PMI_ACC32], 1},
    // 3 ops in INDEX + ACC8
    {&PartMappings[PMI_INDEX], 1},
    {&PartMappings[PMI_INDEX], 1},
    {&PartMappings[PMI_ACC8], 1},
    // 3 ops in INDEX + ACC16
    {&PartMappings[PMI_INDEX], 1},
    {&PartMappings[PMI_INDEX], 1},
    {&PartMappings[PMI_ACC16], 1}};

} // end namespace MC6809
} // end namespace llvm

MC6809RegisterBankInfo::MC6809RegisterBankInfo(const TargetRegisterInfo &TRI)
    : MC6809GenRegisterBankInfo() {}

const RegisterBank &
MC6809RegisterBankInfo::getRegBankFromRegClass(const TargetRegisterClass &RC, LLT) const {
  using namespace MC6809;

  switch (RC.getID()) {
  case BIT1RegClassID:
  case AAcRegClassID:
  case ABcRegClassID:
  case AEcRegClassID:
  case AFcRegClassID:
  case ACC8RegClassID:
  case ADcRegClassID:
  case AWcRegClassID:
  case ACC16RegClassID:
  case AQcRegClassID:
  case ACC32RegClassID:
    return getRegBank(MC6809::ACCUMRegBankID);
  case IXcRegClassID:
  case IYcRegClassID:
  case SScRegClassID:
  case SUcRegClassID:
  case INDEX16RegClassID:
    return getRegBank(MC6809::INDEXRegBankID);
  case CCFlagRegClassID:
  case CCcRegClassID:
  case CCondRegClassID:
  case NZVCcRegClassID:
  case NZcRegClassID:
  case NcRegClassID:
  case ZcRegClassID:
  case VcRegClassID:
  case CcRegClassID:
    return getRegBank(MC6809::CCRegBankID);
  default:
    llvm_unreachable("Unsupported register kind");
  }
}

const RegisterBankInfo::InstructionMapping &
MC6809RegisterBankInfo::getInstrMapping(const MachineInstr &MI) const {
  auto Opc = MI.getOpcode();

  // Try the default logic for non-generic instructions that are either copies
  // or already have some operands assigned to banks.
  if (!isPreISelGenericOpcode(Opc) || Opc == TargetOpcode::G_PHI) {
    const InstructionMapping &Mapping = getInstrMappingImpl(MI);
    if (Mapping.isValid())
      return Mapping;
  }

  using namespace TargetOpcode;

  const MachineFunction &MF = *MI.getParent()->getParent();
  const MachineRegisterInfo &MRI = MF.getRegInfo();
  unsigned NumOperands = MI.getNumOperands();
  const ValueMapping *OperandsMapping = &MC6809::ValueMappings[MC6809::InvalidIdx];

  switch (Opc) {
  case G_ADD:
  case G_SUB: {
    LLT Dst = MRI.getType(MI.getOperand(0).getReg());
    (void)Dst;
    LLT Src1 = MRI.getType(MI.getOperand(1).getReg());
    (void)Src1;
    LLT Src2 = MRI.getType(MI.getOperand(2).getReg());
    (void)Src2;
    assert(Dst.isScalar() && "Non-scalar destination to arithmetic operation");
    assert(Src1.getSizeInBits() == Dst.getSizeInBits() && "Operand 1 incompatible with destination");
    assert(Src1.isScalar() && "Non-scalar operand 1 to arithmetic operation");
    assert(Src2.getSizeInBits() == Dst.getSizeInBits() && "Operand 2 incompatible with destination");
    assert(Src2.isScalar() && "Non-scalar operand 2 to arithmetic operation");
    switch (Dst.getSizeInBits()) {
    case 8:
      OperandsMapping = &MC6809::ValueMappings[MC6809::ACC8_3OpsIdx];
      break;
    case 16:
      OperandsMapping = &MC6809::ValueMappings[MC6809::ACC16_3OpsIdx];
      break;
    default:
      llvm_unreachable("Illegal scalar length for arithmetic operation");
    }
    break;
  }
  case G_AND:
  case G_OR:
  case G_XOR: {
    LLT Dst = MRI.getType(MI.getOperand(0).getReg());
    (void)Dst;
    LLT Src1 = MRI.getType(MI.getOperand(1).getReg());
    (void)Src1;
    LLT Src2 = MRI.getType(MI.getOperand(2).getReg());
    (void)Src2;
    assert(Dst.isScalar() && "Non-scalar destination to logical operation");
    assert(Src1.getSizeInBits() == Dst.getSizeInBits() && "Operand 1 incompatible with destination");
    assert(Src1.isScalar() && "Non-scalar operand 1 to logical operation");
    assert(Src2.getSizeInBits() == Dst.getSizeInBits() && "Operand 2 incompatible with destination");
    assert(Src2.isScalar() && "Non-scalar operand 2 to logical operation");
    switch (Dst.getSizeInBits()) {
    case 1:
      OperandsMapping = &MC6809::ValueMappings[MC6809::BIT1_3OpsIdx];
      break;
    case 8:
      OperandsMapping = &MC6809::ValueMappings[MC6809::ACC8_3OpsIdx];
      break;
    case 16:
      OperandsMapping = &MC6809::ValueMappings[MC6809::ACC16_3OpsIdx];
      break;
    default:
      llvm_unreachable("Illegal scalar length for logical operation");
    }
    break;
  }
  case G_LSHR:
  case G_ASHR:
  case G_SHL: {
    LLT Dst = MRI.getType(MI.getOperand(0).getReg());
    (void)Dst;
    LLT Src1 = MRI.getType(MI.getOperand(1).getReg());
    (void)Src1;
    LLT Src2 = MRI.getType(MI.getOperand(2).getReg());
    (void)Src2;
    assert(Dst.isScalar() && "Non-scalar destination to shift operation");
    assert(Src1.getSizeInBits() == Dst.getSizeInBits() && "Operand 1 incompatible with destination");
    assert(Src1.isScalar() && "Non-scalar operand 1 to shift operation");
    assert(Src2.isScalar() && "Non-scalar operand 2 to shift operation");
    switch (Dst.getSizeInBits()) {
    case 8:
      OperandsMapping = &MC6809::ValueMappings[MC6809::ACC8_3OpsIdx];
      break;
    case 16:
      OperandsMapping = &MC6809::ValueMappings[MC6809::ACC16_3OpsIdx];
      break;
    default:
      llvm_unreachable("Illegal scalar length for shift operation");
    }
    break;
  }
  case G_SEXT:
  case G_ZEXT:
  case G_ANYEXT: {
    LLT Dst = MRI.getType(MI.getOperand(0).getReg());
    (void)Dst;
    LLT Src = MRI.getType(MI.getOperand(1).getReg());
    (void)Src;
    assert(Dst.isScalar() && "Non-scalar destination to extend operation");
    assert(Src.getSizeInBits() < Dst.getSizeInBits() && "Operand for extend not smaller than destination");
    assert(Src.isScalar() && "Non-scalar operand 1 to shift operation");
    switch (Dst.getSizeInBits()) {
    case 8:
      OperandsMapping = getOperandsMapping({&MC6809::ValueMappings[MC6809::ACC8_3OpsIdx],
                                            &MC6809::ValueMappings[MC6809::BIT1_3OpsIdx]});
      break;
    case 16:
      OperandsMapping = getOperandsMapping({&MC6809::ValueMappings[MC6809::ACC16_3OpsIdx],
                                            &MC6809::ValueMappings[MC6809::ACC8_3OpsIdx]});
      break;
    case 32:
      OperandsMapping = getOperandsMapping({&MC6809::ValueMappings[MC6809::ACC32_3OpsIdx],
                                            &MC6809::ValueMappings[MC6809::ACC16_3OpsIdx]});
      break;
    default:
      llvm_unreachable("Illegal scalar length for shift operation");
    }
    break;
  }
  case G_INTTOPTR:
  case G_PTRTOINT: {
    LLT Dst = MRI.getType(MI.getOperand(0).getReg());
    (void)Dst;
    LLT Src = MRI.getType(MI.getOperand(1).getReg());
    (void)Src;
    if (Opc == G_INTTOPTR) {
      assert(Dst.isPointer() && Src.isScalar() && "Incompatible source and destination (int to pointer)");
      assert(Src.getSizeInBits() == 16 && "Int must be 16-bit for conversion from pointer");
      OperandsMapping = getOperandsMapping({&MC6809::ValueMappings[MC6809::INDEX_ACC16_3OpsIdx],
                                            &MC6809::ValueMappings[MC6809::ACC16_3OpsIdx]});
    } else {
      assert(Dst.isScalar() && Src.isPointer() && "Incompatible source and destination (pointer to int)");
      assert(Dst.getSizeInBits() == 16 && "Int must be 16-bit for conversion to pointer");
      OperandsMapping = getOperandsMapping({&MC6809::ValueMappings[MC6809::ACC16_3OpsIdx],
                                            &MC6809::ValueMappings[MC6809::INDEX_ACC16_3OpsIdx]});
    }
    break;
  }
  case G_PTR_ADD: {
    LLT Dst = MRI.getType(MI.getOperand(0).getReg());
    (void)Dst;
    LLT DstIn = MRI.getType(MI.getOperand(1).getReg());
    (void)DstIn;
    LLT Offset = MRI.getType(MI.getOperand(2).getReg());
    (void)Offset;
    assert(Dst.isPointer() && "Non-pointer destination for pointer add");
    assert(DstIn.isPointer() && "Non-pointer source to pointer add");
    assert(Offset.isScalar() && "Non-scalar offset to pointer add");
    switch (Dst.getSizeInBits()) {
    case 8:
      OperandsMapping = &MC6809::ValueMappings[MC6809::INDEX_ACC8_3OpsIdx];
      break;
    case 16:
      OperandsMapping = &MC6809::ValueMappings[MC6809::INDEX_ACC16_3OpsIdx];
      break;
    default:
      llvm_unreachable("Illegal scalar length for shift operation");
    }
    break;
  }
  case G_MUL: {
    LLT Dst = MRI.getType(MI.getOperand(0).getReg());
    (void)Dst;
    LLT Src1 = MRI.getType(MI.getOperand(1).getReg());
    (void)Src1;
    LLT Src2 = MRI.getType(MI.getOperand(2).getReg());
    (void)Src2;
    assert(Dst.isScalar() && "Non-scalar destination to extend operation");
    assert(Src1.getSizeInBits()*2 == Dst.getSizeInBits() && "Operand for multiply not smaller than destination");
    assert(Src1.isScalar() && "Non-scalar operand 1 to multiply operation");
    assert(Src2.getSizeInBits()*2 == Dst.getSizeInBits() && "Operand for multiply not smaller than destination");
    assert(Src2.isScalar() && "Non-scalar operand 1 to shift operation");
    switch (Dst.getSizeInBits()) {
    case 16:
      OperandsMapping = getOperandsMapping({&MC6809::ValueMappings[MC6809::ACC16_3OpsIdx],
                                            &MC6809::ValueMappings[MC6809::ACC8_3OpsIdx],
                                            &MC6809::ValueMappings[MC6809::ACC8_3OpsIdx]});
      break;
    case 32:
      OperandsMapping = getOperandsMapping({&MC6809::ValueMappings[MC6809::ACC32_3OpsIdx],
                                            &MC6809::ValueMappings[MC6809::ACC16_3OpsIdx],
                                            &MC6809::ValueMappings[MC6809::ACC16_3OpsIdx]});
      break;
    default:
      llvm_unreachable("Illegal scalar length for shift operation");
    }
    break;
  }
  case G_TRUNC: {
    LLT Dst = MRI.getType(MI.getOperand(0).getReg());
    (void)Dst;
    LLT Src = MRI.getType(MI.getOperand(1).getReg());
    (void)Src;
    assert(Dst.isScalar() && "Non-scalar destination to truncate operation");
    assert(Src.getSizeInBits() >= Dst.getSizeInBits() && "Source for truncate smaller than target");
    assert(Src.isScalar() && "Non-scalar source to truncate operation");
    switch (Dst.getSizeInBits()) {
    case 1:
      OperandsMapping = getOperandsMapping({&MC6809::ValueMappings[MC6809::BIT1_3OpsIdx],
                                            &MC6809::ValueMappings[MC6809::ACC8_3OpsIdx]});
      break;
    case 8:
      OperandsMapping = getOperandsMapping({&MC6809::ValueMappings[MC6809::ACC8_3OpsIdx],
                                            &MC6809::ValueMappings[MC6809::ACC16_3OpsIdx]});
      break;
    case 16:
      OperandsMapping = getOperandsMapping({&MC6809::ValueMappings[MC6809::ACC16_3OpsIdx],
                                            &MC6809::ValueMappings[MC6809::ACC32_3OpsIdx]});
      break;
    default:
      llvm_unreachable("Illegal scalar target length for truncate operation");
    }
    break;
  }
  case G_LOAD:
  case G_STORE: {
    LLT Reg = MRI.getType(MI.getOperand(0).getReg());
    (void)Reg;
    LLT MemLoc = MRI.getType(MI.getOperand(1).getReg());
    (void)MemLoc;
    assert((Reg.isScalar() || Reg.isPointer()) && "Illegal register type in load/store operation");
    assert(MemLoc.isPointer() && "Non-pointer memory reference in load/store operation");
    switch (Reg.getSizeInBits()) {
    case 1:
      OperandsMapping = getOperandsMapping({&MC6809::ValueMappings[MC6809::BIT1_3OpsIdx],
                                            &MC6809::ValueMappings[MC6809::INDEX_ACC8_3OpsIdx]});
      break;
    case 8:
      OperandsMapping = getOperandsMapping({&MC6809::ValueMappings[MC6809::ACC8_3OpsIdx],
                                            &MC6809::ValueMappings[MC6809::INDEX_ACC8_3OpsIdx]});
      break;
    case 16:
      OperandsMapping = getOperandsMapping({&MC6809::ValueMappings[MC6809::ACC16_3OpsIdx],
                                            &MC6809::ValueMappings[MC6809::INDEX_ACC16_3OpsIdx]});
      break;
    case 32:
      OperandsMapping = getOperandsMapping({&MC6809::ValueMappings[MC6809::ACC32_3OpsIdx],
                                            &MC6809::ValueMappings[MC6809::INDEX_ACC16_3OpsIdx]});
      break;
    default:
      llvm_unreachable("Illegal register length length for load/store operation");
    }
    break;
  }
  case G_IMPLICIT_DEF:
  case G_CONSTANT:
  case G_FRAME_INDEX:
  case G_GLOBAL_VALUE: {
    LLT Reg = MRI.getType(MI.getOperand(0).getReg());
    (void)Reg;
    if (Reg.isScalar()) {
      switch (Reg.getSizeInBits()) {
      case 1:
        OperandsMapping = getOperandsMapping({&MC6809::ValueMappings[MC6809::BIT1_3OpsIdx], nullptr});
        break;
      case 8:
        OperandsMapping = getOperandsMapping({&MC6809::ValueMappings[MC6809::ACC8_3OpsIdx], nullptr});
        break;
      case 16:
        OperandsMapping = getOperandsMapping({&MC6809::ValueMappings[MC6809::ACC16_3OpsIdx], nullptr});
        break;
      case 32:
        OperandsMapping = getOperandsMapping({&MC6809::ValueMappings[MC6809::ACC32_3OpsIdx], nullptr});
        break;
      default:
        llvm_unreachable("Illegal scalar constant target length.");
      }
    } else if (Reg.isPointer()) {
      OperandsMapping = getOperandsMapping({&MC6809::ValueMappings[MC6809::INDEX_ACC16_3OpsIdx], nullptr});
    }
    break;
  }
  case G_SELECT: {
    LLT Dst = MRI.getType(MI.getOperand(0).getReg());
    (void)Dst;
    LLT Sel = MRI.getType(MI.getOperand(1).getReg());
    (void)Sel;
    assert((Dst.getSizeInBits() == 1 || Dst.getSizeInBits() == 8 || Dst.getSizeInBits() == 16 || Dst.getSizeInBits() == 32)
            && "Unsupported target size for select");
    assert(Sel.getSizeInBits() == 1 && "Unsupported selector size for select");
    switch (Dst.getSizeInBits()) {
    case 1:
      OperandsMapping = getOperandsMapping({&MC6809::ValueMappings[MC6809::BIT1_3OpsIdx],
                                            &MC6809::ValueMappings[MC6809::BIT1_3OpsIdx],
                                            &MC6809::ValueMappings[MC6809::BIT1_3OpsIdx],
                                            &MC6809::ValueMappings[MC6809::BIT1_3OpsIdx]});
      break;
    case 8:
      OperandsMapping = getOperandsMapping({&MC6809::ValueMappings[MC6809::ACC8_3OpsIdx],
                                            &MC6809::ValueMappings[MC6809::BIT1_3OpsIdx],
                                            &MC6809::ValueMappings[MC6809::ACC8_3OpsIdx],
                                            &MC6809::ValueMappings[MC6809::ACC8_3OpsIdx]});
      break;
    case 16:
      OperandsMapping = getOperandsMapping({&MC6809::ValueMappings[MC6809::ACC16_3OpsIdx],
                                            &MC6809::ValueMappings[MC6809::BIT1_3OpsIdx],
                                            &MC6809::ValueMappings[MC6809::ACC16_3OpsIdx],
                                            &MC6809::ValueMappings[MC6809::ACC16_3OpsIdx]});
      break;
    case 32:
      OperandsMapping = getOperandsMapping({&MC6809::ValueMappings[MC6809::ACC32_3OpsIdx],
                                            &MC6809::ValueMappings[MC6809::BIT1_3OpsIdx],
                                            &MC6809::ValueMappings[MC6809::ACC32_3OpsIdx],
                                            &MC6809::ValueMappings[MC6809::ACC32_3OpsIdx]});
      break;
    }
    break;
  }
  case G_ICMP: {
    LLT Dst = MRI.getType(MI.getOperand(0).getReg());
    (void)Dst;
    assert((Dst.isScalar() || Dst.isPointer()) && "Unsupported destination for icmp");
    LLT Ty2 = MRI.getType(MI.getOperand(2).getReg());
    (void)Ty2;
    assert((Ty2.isScalar() || Ty2.isPointer()) && "Unsupported source for icmp 2");
    LLT Ty3 = MRI.getType(MI.getOperand(3).getReg());
    (void)Ty3;
    assert((Ty3.isScalar() || Ty3.isPointer()) && "Unsupported source for icmp 3");
    assert((Ty2.getElementType() == Ty3.getElementType()) && "Unequal types in icmp compare");
    switch (Dst.getSizeInBits()) {
    case 1:
      OperandsMapping = getOperandsMapping({&MC6809::ValueMappings[MC6809::BIT1_3OpsIdx],
                                            &MC6809::ValueMappings[MC6809::BIT1_3OpsIdx],
                                            &MC6809::ValueMappings[MC6809::BIT1_3OpsIdx],
                                            &MC6809::ValueMappings[MC6809::BIT1_3OpsIdx]});
      break;
    case 8:
      OperandsMapping = getOperandsMapping({&MC6809::ValueMappings[MC6809::ACC8_3OpsIdx],
                                            &MC6809::ValueMappings[MC6809::BIT1_3OpsIdx],
                                            &MC6809::ValueMappings[MC6809::ACC8_3OpsIdx],
                                            &MC6809::ValueMappings[MC6809::ACC8_3OpsIdx]});
      break;
    case 16:
      OperandsMapping = getOperandsMapping({&MC6809::ValueMappings[MC6809::ACC16_3OpsIdx],
                                            &MC6809::ValueMappings[MC6809::BIT1_3OpsIdx],
                                            &MC6809::ValueMappings[MC6809::ACC16_3OpsIdx],
                                            &MC6809::ValueMappings[MC6809::ACC16_3OpsIdx]});
      break;
    case 32:
      OperandsMapping = getOperandsMapping({&MC6809::ValueMappings[MC6809::ACC32_3OpsIdx],
                                            &MC6809::ValueMappings[MC6809::BIT1_3OpsIdx],
                                            &MC6809::ValueMappings[MC6809::ACC32_3OpsIdx],
                                            &MC6809::ValueMappings[MC6809::ACC32_3OpsIdx]});
      break;
    }
    break;
  }
  case G_MERGE_VALUES: {
    LLT Dst = MRI.getType(MI.getOperand(0).getReg());
    (void)Dst;
    LLT Src1 = MRI.getType(MI.getOperand(1).getReg());
    (void)Src1;
    LLT Src2 = MRI.getType(MI.getOperand(2).getReg());
    (void)Src2;
    assert(Dst.isScalar() && "Non-scalar destination to merge operation");
    assert(Src1.getSizeInBits()*2 == Dst.getSizeInBits() && "Operand for merge not smaller than destination");
    assert(Src1.isScalar() && "Non-scalar operand 1 to merge operation");
    assert(Src2.getSizeInBits()*2 == Dst.getSizeInBits() && "Operand for merge not smaller than destination");
    assert(Src2.isScalar() && "Non-scalar operand 1 to merge operation");
    switch (Dst.getSizeInBits()) {
    case 16:
      OperandsMapping = getOperandsMapping({&MC6809::ValueMappings[MC6809::ACC16_3OpsIdx],
                                            &MC6809::ValueMappings[MC6809::ACC8_3OpsIdx],
                                            &MC6809::ValueMappings[MC6809::ACC8_3OpsIdx]});
      break;
    case 32:
      OperandsMapping = getOperandsMapping({&MC6809::ValueMappings[MC6809::ACC32_3OpsIdx],
                                            &MC6809::ValueMappings[MC6809::ACC16_3OpsIdx],
                                            &MC6809::ValueMappings[MC6809::ACC16_3OpsIdx]});
      break;
    default:
      llvm_unreachable("Illegal scalar destination for merge operation");
    }
    break;
  }
  case G_UNMERGE_VALUES: {
    LLT Dst1 = MRI.getType(MI.getOperand(0).getReg());
    (void)Dst1;
    LLT Dst2 = MRI.getType(MI.getOperand(1).getReg());
    (void)Dst2;
    LLT Src = MRI.getType(MI.getOperand(2).getReg());
    (void)Src;
    assert(Dst1.isScalar() && "Non-scalar destination 1 to un-merge operation");
    assert(Dst2.isScalar() && "Non-scalar destination 2 to un-merge operation");
    assert(Src.isScalar() && "Non-scalar source to un-merge operation");
    assert(Dst1.getSizeInBits()*2 == Src.getSizeInBits() && "Operand for un-merge not smaller than source");
    assert(Dst2.getSizeInBits()*2 == Src.getSizeInBits() && "Operand for un-merge not smaller than source");
    switch (Src.getSizeInBits()) {
    case 16:
      OperandsMapping = getOperandsMapping({&MC6809::ValueMappings[MC6809::ACC8_3OpsIdx],
                                            &MC6809::ValueMappings[MC6809::ACC8_3OpsIdx],
                                            &MC6809::ValueMappings[MC6809::ACC16_3OpsIdx]});
      break;
    case 32:
      OperandsMapping = getOperandsMapping({&MC6809::ValueMappings[MC6809::ACC16_3OpsIdx],
                                            &MC6809::ValueMappings[MC6809::ACC16_3OpsIdx],
                                            &MC6809::ValueMappings[MC6809::ACC32_3OpsIdx]});
      break;
    default:
      llvm_unreachable("Illegal scalar source for un-merge operation");
    }
    break;
  }
  case G_BR:
    OperandsMapping = getOperandsMapping({nullptr});
    break;
  case G_BRCOND:
    OperandsMapping = getOperandsMapping({&MC6809::ValueMappings[MC6809::ACC8_3OpsIdx], nullptr});
    break;
  case DBG_VALUE: {
    SmallVector<const ValueMapping *, 4> OperandBanks(NumOperands);
    const MachineOperand &MaybeReg = MI.getOperand(0);
    if (MaybeReg.isReg() && MaybeReg.getReg()) {
      unsigned Size = MRI.getType(MaybeReg.getReg()).getSizeInBits();
      if (Size > 16)
        return getInvalidInstructionMapping();
      OperandBanks[0] = &MC6809::ValueMappings[MC6809::ACC16_3OpsIdx];
    }
    OperandsMapping = getOperandsMapping(OperandBanks);
    break;
  }
  default:
    return getInvalidInstructionMapping();
  }

  return getInstructionMapping(DefaultMappingID, /*Cost=*/1, OperandsMapping, NumOperands);
}
