//===-- MC6809FrameLowering.cpp - MC6809 Frame Information ----------------------===//
//
// Part of LLVM-MC6809, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
//
// This file contains the MC6809 implementation of TargetFrameLowering class.
//
//===----------------------------------------------------------------------===//

#include "MC6809FrameLowering.h"

#include "MCTargetDesc/MC6809MCTargetDesc.h"
#include "MC6809.h"
#include "MC6809MachineFunctionInfo.h"
#include "MC6809RegisterInfo.h"
#include "MC6809Subtarget.h"

#include "llvm/CodeGen/GlobalISel/CallLowering.h"
#include "llvm/CodeGen/GlobalISel/MachineIRBuilder.h"
#include "llvm/CodeGen/MachineBasicBlock.h"
#include "llvm/CodeGen/MachineFrameInfo.h"
#include "llvm/CodeGen/MachineFunction.h"
#include "llvm/CodeGen/MachineInstrBuilder.h"
#include "llvm/CodeGen/MachineOperand.h"
#include "llvm/CodeGen/MachineRegisterInfo.h"
#include "llvm/CodeGen/PseudoSourceValue.h"
#include "llvm/CodeGen/TargetFrameLowering.h"
#include "llvm/CodeGen/TargetInstrInfo.h"
#include "llvm/CodeGen/TargetRegisterInfo.h"
#include "llvm/Support/Compiler.h"
#include "llvm/Support/ErrorHandling.h"

#define DEBUG_TYPE "mc6809-framelowering"

using namespace llvm;

MC6809FrameLowering::MC6809FrameLowering()
    : TargetFrameLowering(StackGrowsDown, /*StackAlignment=*/Align(1),
                          /*LocalAreaOffset=*/0) {}

bool MC6809FrameLowering::assignCalleeSavedSpillSlots(
    MachineFunction &MF, const TargetRegisterInfo *TRI,
    std::vector<CalleeSavedInfo> &CSI) const {
  MachineFrameInfo &MFI = MF.getFrameInfo();

  for (const auto &Info : enumerate(CSI)) {
    // We place the first four CSRs on the hard stack, which we don't explicitly
    // model in PEI.
    if (Info.index() < 4)
      Info.value().setTargetSpilled();
    else
      Info.value().setFrameIdx(MFI.CreateSpillStackObject(1, Align()));
  }

  return true;
}

bool MC6809FrameLowering::enableShrinkWrapping(const MachineFunction &MF) const {
  // Prologues and epilogues are pretty expensive on the 6502: 16-bit additions,
  // saving/restoring CSRs, the works. Accordingly, it's usually a good idea to
  // do shrink wrapping, as this can make prolog/epilogue execution conditional,
  // with no downside.
  //
  // If we're in an interrupt handler, we'll need to save a number of temporary
  // locations, but the uses of those locations haven't been generated by the
  // time shrink wrapping occurs.  Since there's no way for shrink wrapping to
  // determine which blocks will eventually use those locations, we can't use it
  // in that case.
  return !isISR(MF);
}

bool MC6809FrameLowering::spillCalleeSavedRegisters(
    MachineBasicBlock &MBB, MachineBasicBlock::iterator MI,
    ArrayRef<CalleeSavedInfo> CSI, const TargetRegisterInfo *TRI) const {
  MachineIRBuilder Builder(MBB, MI);
  MachineInstrSpan MIS(MI, &MBB);
  const MC6809Subtarget &STI = MBB.getParent()->getSubtarget<MC6809Subtarget>();
  const TargetInstrInfo &TII = *STI.getInstrInfo();
  const TargetRegisterClass &StackRegClass = MC6809::ACCRegClass;

  // There are intentionally very few CSRs, few enough to place on the hard
  // stack without much risk of overflow. This is the only across-calls way
  // the compiler uses the hard stack, since the free CSRs can then be used
  // with impunity. This is slightly more expensive than saving/resting values
  // directly on the hard stack, but it's significantly simpler.
  for (const CalleeSavedInfo &CI : CSI) {
    Register Reg = CI.getReg();
    if (!CI.isTargetSpilled())
      continue;
    if (!StackRegClass.contains(Reg))
      Reg = Builder.buildCopy(&StackRegClass, Reg).getReg(0);
    Builder.buildInstr(MC6809::PH, {}, {Reg});
  }

  // Record that the frame pointer is killed by these instructions.
  for (auto &MI : make_range(MIS.begin(), MIS.getInitial()))
    MI.setFlag(MachineInstr::FrameSetup);

  // The frame pointer will be generated after the last frame setup instruction.

  // Save registers to the soft stack afterwards, since this may require the
  // frame pointer.
  for (const CalleeSavedInfo &CI : CSI) {
    Register Reg = CI.getReg();
    if (CI.isTargetSpilled())
      continue;
    assert(!CI.isSpilledToReg());
    const TargetRegisterClass *RC = TRI->getMinimalPhysRegClass(Reg);
    TII.storeRegToStackSlot(MBB, Builder.getInsertPt(), Reg, true,
                            CI.getFrameIdx(), RC, TRI);
  }

  return true;
}

template <typename F, typename VisitSet>
static void visitReturnBlocks(MachineBasicBlock *MBB, const F &Func,
                              VisitSet &VisitedBBs) {
  if (!VisitedBBs.insert(MBB).second)
    return;
  if (MBB->isReturnBlock())
    Func(*MBB);

  // Follow branches in BB and look for returns
  for (MachineBasicBlock *Succ : MBB->successors())
    visitReturnBlocks(Succ, Func, VisitedBBs);
}

template <typename F>
static void visitReturnBlocks(MachineBasicBlock *MBB, const F &Func) {
  SmallSet<MachineBasicBlock *, 32> VisitedBBs;
  visitReturnBlocks(MBB, Func, VisitedBBs);
}

bool MC6809FrameLowering::restoreCalleeSavedRegisters(
    MachineBasicBlock &MBB, MachineBasicBlock::iterator MI,
    MutableArrayRef<CalleeSavedInfo> CSI, const TargetRegisterInfo *TRI) const {
  MachineIRBuilder Builder(MBB, MI);
  const MC6809Subtarget &STI = MBB.getParent()->getSubtarget<MC6809Subtarget>();
  const TargetInstrInfo &TII = *STI.getInstrInfo();
  const TargetRegisterClass &StackRegClass = MC6809::ACCRegClass;

  for (const CalleeSavedInfo &CI : reverse(CSI)) {
    Register Reg = CI.getReg();
    if (CI.isTargetSpilled())
      continue;
    assert(!CI.isSpilledToReg());
    const TargetRegisterClass *RC = TRI->getMinimalPhysRegClass(Reg);
    TII.loadRegFromStackSlot(MBB, Builder.getInsertPt(), Reg, CI.getFrameIdx(),
                             RC, TRI);
  }

  // Begin tracking the frame pointer exclusion region only after all soft stack
  // CSR restores are emitted.
  MachineInstrSpan MIS(MI, &MBB);

  for (const CalleeSavedInfo &CI : reverse(CSI)) {
    Register Reg = CI.getReg();
    if (!CI.isTargetSpilled())
      continue;
    if (!StackRegClass.contains(Reg))
      Reg = Builder.getMRI()->createVirtualRegister(&StackRegClass);
    Builder.buildInstr(MC6809::PL, {Reg}, {});
    if (Reg != CI.getReg())
      Builder.buildCopy(CI.getReg(), Reg);
  }

  // Mark the CSRs as used by the return to ensure Machine Copy Propagation
  // doesn't remove the copies that set them.
  visitReturnBlocks(&MBB, [&CSI](MachineBasicBlock &MBB) {
    assert(MBB.rbegin()->isReturn());
    for (const CalleeSavedInfo &CI : CSI) {
      MBB.rbegin()->addOperand(MachineOperand::CreateReg(
          CI.getReg(), /*isDef=*/false, /*isImp=*/true));
    }
  });

  // Record that the frame pointer is killed by these instructions.
  for (auto &MI : make_range(MIS.begin(), MIS.getInitial()))
    MI.setFlag(MachineInstr::FrameDestroy);

  return true;
}

void MC6809FrameLowering::determineCalleeSaves(MachineFunction &MF,
                                            BitVector &SavedRegs,
                                            RegScavenger *RS) const {
  TargetFrameLowering::determineCalleeSaves(MF, SavedRegs, RS);

  // If we have a frame pointer, the frame register RS15 needs to be saved as
  // well, since the code that uses it hasn't yet been emitted.
  if (hasFP(MF))
    SavedRegs.set(MC6809::SU);
}

void MC6809FrameLowering::processFunctionBeforeFrameFinalized(
    MachineFunction &MF, RegScavenger *RS) const {
  MachineFrameInfo &MFI = MF.getFrameInfo();

  // Assign all locals to static stack in non-recursive functions.
  if (MF.getFunction().doesNotRecurse()) {
    int64_t Offset = 0;
    for (int Idx : seq(0, MFI.getObjectIndexEnd())) {
      if (MFI.isDeadObjectIndex(Idx) || MFI.isVariableSizedObjectIndex(Idx))
        continue;

      MFI.setStackID(Idx, TargetStackID::NoAlloc);
      MFI.setObjectOffset(Idx, Offset);
      Offset += MFI.getObjectSize(Idx); // Static stack grows up.
    }
    return;
  }
}

MachineBasicBlock::iterator MC6809FrameLowering::eliminateCallFramePseudoInstr(
    MachineFunction &MF, MachineBasicBlock &MBB,
    MachineBasicBlock::iterator MI) const {
  int64_t Offset = MI->getOperand(0).getImm();

  // If we've already reserved the outgoing call frame in the prolog/epilog, the
  // pseudo can be summarily removed.
  if (hasReservedCallFrame(MF) || !Offset)
    return MBB.erase(MI);

  // Increment/decrement the stack pointer to reserve space for the call frame.
  MachineIRBuilder Builder(MBB, MI);
  if (MI->getOpcode() ==
      MF.getSubtarget().getInstrInfo()->getCallFrameSetupOpcode())
    Offset = -Offset;
  offsetSP(Builder, Offset);
  return MBB.erase(MI);
}

void MC6809FrameLowering::emitPrologue(MachineFunction &MF,
                                    MachineBasicBlock &MBB) const {
  const MachineFrameInfo &MFI = MF.getFrameInfo();
  const TargetRegisterInfo &TRI = *MF.getRegInfo().getTargetRegisterInfo();
  MachineIRBuilder Builder(MBB, MBB.begin());

  int64_t StackSize = MFI.getStackSize();
  // If the interrupted routine is in the middle of decrementing its stack
  // pointer, this routine may observe a stack pointer up to 255 bytes higher
  // than its atomic value.  Accordingly, summarily decrement the SP by a page.
  // Interrupts are rarer than the the routines they interrupt, so they pay the
  // cost of dealing with this atomicity problem.
  if (isISR(MF))
    StackSize += 256;

  if (StackSize)
    offsetSP(Builder, -StackSize);

  if (!hasFP(MF))
    return;

  // Skip the callee-saved push instructions.
  auto MBBI = std::find_if_not(Builder.getInsertPt(), MBB.end(),
                               [](const MachineInstr &MI) {
                                 return MI.getFlag(MachineInstr::FrameSetup);
                               });

  // Set the frame pointer to the stack pointer.
  Builder.setInsertPt(MBB, MBBI);
  Builder.buildCopy(TRI.getFrameRegister(MF), Register(MC6809::SS));
}

void MC6809FrameLowering::emitEpilogue(MachineFunction &MF,
                                    MachineBasicBlock &MBB) const {
  const MachineFrameInfo &MFI = MF.getFrameInfo();
  const TargetRegisterInfo &TRI = *MF.getRegInfo().getTargetRegisterInfo();
  MachineIRBuilder Builder(MBB, MBB.getFirstTerminator());

  // Restore the stack pointer from the frame pointer.
  if (hasFP(MF)) {
    // Skip the callee-saved push instructions.
    auto MBBI = find_if_not(mbb_reverse(MBB.begin(), Builder.getInsertPt()),
                            [](const MachineInstr &MI) {
                              return MI.getFlag(MachineInstr::FrameDestroy);
                            });
    Builder.setInsertPt(MBB, MachineBasicBlock::iterator(MBBI));

    // Set the stack pointer to the frame pointer.
    Builder.buildCopy(MC6809::SS, TRI.getFrameRegister(MF));
    Builder.setInsertPt(MBB, MBB.getFirstTerminator());
  }

  int64_t StackSize = MFI.getStackSize();

  if (isISR(MF))
    StackSize += 256;

  // If soft stack is used, increase the soft stack pointer SP.
  if (StackSize)
    offsetSP(Builder, StackSize);
}

bool MC6809FrameLowering::hasFP(const MachineFunction &MF) const {
  const MachineFrameInfo &MFI = MF.getFrameInfo();
  return MFI.isFrameAddressTaken() || MFI.hasVarSizedObjects();
}

uint64_t MC6809FrameLowering::staticSize(const MachineFrameInfo &MFI) const {
  uint64_t Size = 0;
  for (int Idx : seq(0, MFI.getObjectIndexEnd()))
    if (MFI.getStackID(Idx) == TargetStackID::NoAlloc)
      Size += MFI.getObjectSize(Idx);
  return Size;
}

void MC6809FrameLowering::offsetSP(MachineIRBuilder &Builder,
                                int64_t Offset) const {
  assert(Offset);
  assert(-32768 <= Offset && Offset < 32768);

  Register A = Builder.getMRI()->createVirtualRegister(&MC6809::ACC16RegClass);
  Builder.buildCopy(A, Register(MC6809::SS));
  auto Add = Builder.buildInstr(MC6809::ADCImm, {A}, {Offset});
  Builder.buildCopy(MC6809::SS, A);
}

bool MC6809FrameLowering::isISR(const MachineFunction &MF) const {
  const Function &F = MF.getFunction();
  if (F.hasFnAttribute("no-isr"))
    return false;
  return F.hasFnAttribute("interrupt") ||
         F.hasFnAttribute("interrupt-norecurse");
}
