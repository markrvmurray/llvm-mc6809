//===- MC6809GenRegisterBankInfo.def ----------------------------*- C++ -*-===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
/// \file
/// This file defines all the static objects used by MC6809RegisterBankInfo.
/// \todo This should be generated by TableGen.
//===----------------------------------------------------------------------===//

#ifdef GET_TARGET_REGBANK_INFO_IMPL
RegisterBankInfo::PartialMapping MC6809GenRegisterBankInfo::PartMappings[]{
    /* StartIdx, Length, RegBank */
    // ACC value
    {0, 8,  MC6809::ACCUMRegBank},  // :0
    {0, 16, MC6809::ACCUMRegBank},  // :1
    {0, 32, MC6809::ACCUMRegBank},  // :2
    // ACC value
    {0, 16, MC6809::INDEXRegBank},  // :3
    // CC value
    {0, 8,  MC6809::CCRegBank},     // :4
};
#endif // GET_TARGET_REGBANK_INFO_IMPL

#ifdef GET_TARGET_REGBANK_INFO_CLASS
enum PartialMappingIdx {
  PMI_None = -1,
  PMI_ACC8,
  PMI_ACC16,
  PMI_ACC32,
  PMI_INDEX,
  PMI_COND
};
#endif // GET_TARGET_REGBANK_INFO_CLASS

#ifdef GET_TARGET_REGBANK_INFO_IMPL
#define INSTR_3OP(INFO) INFO, INFO, INFO,
#define BREAKDOWN(INDEX, NUM)                                                  \
  { &MC6809GenRegisterBankInfo::PartMappings[INDEX], NUM }
// ValueMappings.
RegisterBankInfo::ValueMapping MC6809GenRegisterBankInfo::ValMappings[]{
    /* BreakDown, NumBreakDowns */
    // 3-operands instructions (all binary operations should end up with one of
    // those mapping).
    INSTR_3OP(BREAKDOWN(PMI_ACC8, 1))  // 0: ACC_8
    INSTR_3OP(BREAKDOWN(PMI_ACC16, 1)) // 3: ACC_16
    INSTR_3OP(BREAKDOWN(PMI_ACC32, 1)) // 6: ACC_32
    INSTR_3OP(BREAKDOWN(PMI_INDEX, 1)) // 9: INDEX
    INSTR_3OP(BREAKDOWN(PMI_COND, 1))    //12: CC
};
#undef INSTR_3OP
#undef BREAKDOWN
#endif // GET_TARGET_REGBANK_INFO_IMPL

#ifdef GET_TARGET_REGBANK_INFO_CLASS
enum ValueMappingIdx {
  VMI_None = -1,
  VMI_3OpsGpr8Idx =  PMI_ACC8  * 3,
  VMI_3OpsGpr16Idx = PMI_ACC16 * 3,
  VMI_3OpsGpr32Idx = PMI_ACC32 * 3,
};
#undef GET_TARGET_REGBANK_INFO_CLASS
#endif // GET_TARGET_REGBANK_INFO_CLASS

#ifdef GET_TARGET_REGBANK_INFO_IMPL
#undef GET_TARGET_REGBANK_INFO_IMPL
const RegisterBankInfo::ValueMapping *
MC6809GenRegisterBankInfo::getValueMapping(PartialMappingIdx Idx, unsigned NumOperands) {
  LLVM_DEBUG(dbgs() << "OINQUE DEBUG " << __func__ << " : Enter\n";);
  // We can use VMI_3Ops Mapping for all the cases.
  // XXXX: FixMe: MarkM - Oh, no we can't! This should only be valid if NumOperands == 1
  if (NumOperands <= 3) {
    if (Idx >= PMI_ACC8 && Idx <= PMI_ACC32) {
      LLVM_DEBUG(dbgs() << "OINQUE DEBUG " << __func__ << " : Exit : return accumulator\n";);
      return &ValMappings[(unsigned)Idx * 3];
    } else if (Idx == PMI_INDEX) {
      LLVM_DEBUG(dbgs() << "OINQUE DEBUG " << __func__ << " : Exit : return pointer\n";);
      return &ValMappings[(unsigned)Idx * 3];
    } else if (Idx == PMI_COND) {
      LLVM_DEBUG(dbgs() << "OINQUE DEBUG " << __func__ << " : Exit : return CC bit\n";);
      return &ValMappings[(unsigned)Idx * 3];
    }
  }
  llvm_unreachable("Unsupported PartialMappingIdx.");
}

#endif // GET_TARGET_REGBANK_INFO_IMPL
